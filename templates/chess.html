<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Arena Online - Juego de Ajedrez Completo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Slab:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --board-light: #f0d9b5;
            --board-dark: #b58863;
            --futuristic-light: #0d1a2e;
            --futuristic-dark: #050814;
            --neon-blue: #00aaff;
            --neon-purple: #aa00ff;
            --neon-aqua: #64ffda;
            --neon-pink: #ff5291;
            --piece-color-white: #f5f5f5;
            --piece-color-black: #333333;

            /* RGB versions for opacity */
            --primary-color-rgb: 52, 152, 219;
            --secondary-color-rgb: 46, 204, 113;
            --danger-color-rgb: 231, 76, 60;
            --warning-color-rgb: 243, 156, 18;
            --dark-color-rgb: 44, 62, 80; /* Already used for checkmate overlay */
            --light-color-rgb: 236, 240, 241;
            --neon-blue-rgb: 0, 170, 255;
            --neon-aqua-rgb: 100, 255, 218;
            --neon-yellow: #FFFF33; /* Un amarillo neón brillante */
            --neon-yellow-rgb: 255, 255, 51;

            /* --- Theme Variables (Night Mode Default) --- */
            --bg-main: #34495e;
            --text-main: var(--light-color);
            --text-muted-main: #bdc3c7;
            --bg-card: rgba(var(--dark-color-rgb), 0.75);
            --border-card: rgba(255, 255, 255, 0.1);
            --shadow-card: 0 8px 25px rgba(0,0,0,0.25);
            --text-card-title: var(--primary-color);
            --border-card-title: rgba(var(--primary-color-rgb), 0.3);
            --bg-list-item: rgba(var(--dark-color-rgb), 0.7);
            --border-list-item: rgba(255,255,255,0.15);
            --text-list-item: var(--light-color);
            --bg-list-item-hover: rgba(var(--primary-color-rgb), 0.4);
            --text-list-item-hover: var(--neon-aqua);
            --border-list-item-hover: var(--neon-aqua);
            --bg-input: rgba(var(--dark-color-rgb), 0.7);
            --border-input: rgba(255,255,255,0.2);
            --text-input: var(--light-color);
            --placeholder-input: #95a5a6;
            --bg-modal: var(--dark-color);
            --border-modal: rgba(var(--light-color-rgb),0.2);
            --text-modal-title: var(--primary-color);
            --text-modal-body: var(--light-color);
            --board-classic-light: var(--board-light);
            --board-classic-dark: var(--board-dark);
            --btn-outline-text: var(--light-color); /* For outline buttons */
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            overflow-x: hidden;
            font-size: 16px; /* Base font size for better readability */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .chess-board {
            width: 480px; /* Tamaño fijo para el tablero */
            /* max-width y min-width eliminados para tamaño fijo */
            aspect-ratio: 1/1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 12px solid var(--board-classic-dark); /* Use variable for border */
            border-radius: 8px;
            margin: 10px auto;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4), inset 0 0 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            position: relative; /* For checkmate overlay positioning */
        }
        
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 38px; /* Tamaño fijo para las piezas (caracteres de fuente) */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease; /* Added transform for selected */
            position: relative;
            user-select: none;
            /* Asegura que la casilla llene su celda de la cuadrícula */
            width: 100%;
            height: 100%;
            box-sizing: border-box; /* Importante si añades padding o border a .square directamente */
        }
        
        /* General Piece Colors */
        .piece-white { color: var(--piece-color-white); }
        .piece-black { color: var(--piece-color-black); }

        /* Classic theme */
        .piece-style-classic .square.light { background-color: var(--board-classic-light); }
        .piece-style-classic .square.dark { background-color: var(--board-classic-dark); }
        
        .piece-style-classic .piece-white { text-shadow: 0px 1px 2px rgba(0,0,0,0.5); }
        .piece-style-classic .piece-black { text-shadow: 0px 1px 2px rgba(150,150,150,0.4); } /* Lighter shadow for black pieces for contrast */
        
        /* Futuristic theme */
        .futuristic-board-active .square.light {
            background-color: var(--futuristic-light);
            border: 1px solid var(--neon-blue);
            box-shadow: inset 0 0 10px rgba(0, 170, 255, 0.6), 0 0 5px rgba(0, 170, 255, 0.3);
        }
        .futuristic-board-active .square.dark {
            background-color: var(--futuristic-dark);
            border: 1px solid var(--neon-purple);
            box-shadow: inset 0 0 10px rgba(170, 0, 255, 0.6), 0 0 5px rgba(170, 0, 255, 0.3);
        }
        /* Futuristic pieces - these target the .piece span within a specially classed square */
        .futuristic-board-active .square.futuristic-white-piece .piece {
            color: var(--neon-aqua) !important; /* Override general .piece-white */
            text-shadow: 0 0 5px var(--neon-aqua), 0 0 10px var(--neon-aqua), 0 0 15px #fff, 0 0 20px var(--neon-aqua);
            animation: pulseFuturistic 2.5s infinite alternate;
        }
        .futuristic-board-active .square.futuristic-black-piece .piece {
            color: var(--neon-pink) !important; /* Override general .piece-black */
            text-shadow: 0 0 5px var(--neon-pink), 0 0 10px var(--neon-pink), 0 0 15px #fff, 0 0 20px var(--neon-pink);
            animation: pulseFuturistic 2.5s infinite alternate 0.5s;
        }
        
        /* Lego theme */
        .lego-board-active { border-color: #e74c3c; }
        .lego-board-active .square.light {
            background-color: #f9e3a1;
            border: 1px solid #f0d9b5;
        }
        .lego-board-active .square.dark {
            background-color: #d95550;
            border: 1px solid #b58863;
        }
        .piece-style-lego .piece { /* General Lego style for pieces */
            filter: saturate(1.8) brightness(1.2);
            text-shadow: 1px 1px 0 rgba(0,0,0,0.1), 2px 2px 0 rgba(0,0,0,0.1);
            font-weight: bold;
        }
        /* Lego piece colors will use the base .piece-white and .piece-black definitions */

        .square.selected {
            background-color: var(--warning-color) !important; /* Important to override other square bg */
            box-shadow: inset 0 0 15px rgba(0,0,0,0.6);
            transform: scale(0.95);
        }
        
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: rgba(46, 204, 113, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .square.capture-move::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            background-color: transparent;
            border: 4px solid rgba(231, 76, 60, 0.6);
            border-radius: 50%;
            box-sizing: border-box;
            pointer-events: none;
        }
        
        @keyframes pulseFuturistic {
            from { opacity: 0.7; transform: scale(1); }
            to { opacity: 1; transform: scale(1.05); }
        }
        
        /* Splash Screen Enhancements */
        #splashScreen h1 {
            font-size: clamp(2.5rem, 6vw, 4rem); /* Responsive but larger */
            font-family: 'Roboto Slab', serif;
            color: var(--light-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px var(--neon-blue); /* Added subtle neon glow */
            margin-bottom: 0.75rem;
        }
        #splashScreen p {
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            color: var(--light-color); /* Ensure good contrast */
            margin-bottom: 2rem;
        }
        #splashScreen .btn-start-game {
            padding: 0.8rem 2rem;
            font-size: 1.2rem;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        /* Existing splashScreen animations and hidden class are fine */
        #splashScreen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, var(--dark-color), var(--bg-main)); /* Use var */
            text-align: center;
            animation: zoomIn 0.8s ease-out;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 2000; /* Ensure it's on top */
        }
        #splashScreen.hidden { display: none; }


        #gameContainer {
            min-height: 100vh;
            background: linear-gradient(135deg, var(--dark-color), var(--bg-main)); /* Use var */
            padding-top: 80px; /* Adjusted for potentially taller audio controls if they wrap */
            display: none;
        }
        
        .status-check {
            color: var(--warning-color) !important;
            animation: pulseCheck 1.5s infinite;
        }
        @keyframes pulseCheck { /* ... existing ... */ }

        .status-select-opponent {
            color: var(--neon-yellow) !important; /* Asegura que este color se aplique */
            text-shadow: 0 0 4px var(--neon-yellow),
                         0 0 8px var(--neon-yellow),
                         0 0 12px rgba(var(--neon-yellow-rgb), 0.7),
                         0 0 16px rgba(var(--neon-yellow-rgb), 0.5),
                         0 0 2px #fff; /* Un núcleo blanco muy sutil para brillo */
            animation: blinkNeonYellow 1.3s infinite alternate ease-in-out;
        }

        @keyframes blinkNeonYellow {
            from {
                opacity: 0.65;
                text-shadow: 0 0 3px var(--neon-yellow),
                             0 0 6px var(--neon-yellow),
                             0 0 9px rgba(var(--neon-yellow-rgb), 0.5);
            }
            to {
                opacity: 1;
                text-shadow: 0 0 4px var(--neon-yellow),
                             0 0 8px var(--neon-yellow),
                             0 0 12px rgba(var(--neon-yellow-rgb), 0.7),
                             0 0 16px rgba(var(--neon-yellow-rgb), 0.5),
                             0 0 2px #fff;
            }
        }

        /* Existing splashScreen animations */
        @keyframes fadeInDown { /* ... existing ... */ }
        @keyframes fadeInUp { /* ... existing ... */ }
        @keyframes zoomIn { /* ... existing ... */ }
        
        #audioControls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(var(--dark-color-rgb), 0.95); /* Darker, more integrated */
            padding: 8px 15px; /* Adjusted padding */
            z-index: 1040;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            align-items: center;
            justify-content: space-between;
            color: white;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5), 0 0 15px rgba(var(--neon-blue-rgb, 0,170,255), 0.3); /* Neon hint */
            display: none;
        }
        #audioControls > div {
            margin: 5px 10px; /* Spacing between control groups */
        }
        
        #audioControls .volume-slider {
            width: 100px; /* Slightly smaller */
            margin: 0 8px;
            vertical-align: middle;
        }
        
        #audioControls button {
            margin: 0 3px;
            border-radius: 5px; /* More standard radius */
            font-size: 0.9rem; /* Original: 0.85rem */
            padding: 5px 12px; /* Original: 4px 10px */
        }
        
        #audioControls label {
            margin-right: 3px;
            font-size: 0.9rem; /* Original: 0.85rem */
            vertical-align: middle;
        }
        
        /* Contenedor para el logo y el título */
        #audioControls .title-area {
            display: flex;
            align-items: center;
            justify-content: center; /* Centra el contenido (logo + título) en móviles */
            order: -1; /* Mantiene el grupo al principio en móviles */
            flex-basis: 100%; /* Ocupa todo el ancho en móviles */
            text-align: center; 
            margin-bottom: 5px; /* Espaciado inferior en móviles */
        }

        /* Estilos para el enlace del logo */
        .logo-button-link {
            display: inline-block;
            padding: 4px;
            margin-right: 10px;
            border-radius: 6px;
            background-color: rgba(var(--dark-color-rgb), 0.5);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 7px var(--neon-blue), 
                        0 0 10px var(--neon-blue), 
                        inset 0 0 4px rgba(var(--neon-blue-rgb), 0.4);
            transition: all 0.25s ease-in-out;
        }
        .logo-button-link:hover {
            background-color: rgba(var(--neon-blue-rgb), 0.2);
            box-shadow: 0 0 10px var(--neon-blue), 
                        0 0 15px var(--neon-blue), 
                        0 0 20px var(--neon-aqua), 
                        inset 0 0 6px rgba(var(--neon-blue-rgb), 0.6);
            transform: scale(1.08) rotate(-3deg);
        }

        .header-logo {
            width: 28px;
            height: 28px;
            display: block;
            border-radius: 4px;
        }

        /* El título dentro del nuevo contenedor .title-area */
        #audioControls .title-area .game-title-bar {
            font-family: 'Roboto Slab', serif;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 1px;
            /* Los estilos de layout (order, flex-basis, etc.) son manejados por .title-area */
        }


        @media (min-width: 768px) { 
            #audioControls .title-area {
                flex-basis: auto; /* Tamaño según contenido */
                order: 0; /* Posición normal en el flujo */
                margin-bottom: 0; /* Sin margen inferior */
                justify-content: flex-start; /* Alinea a la izquierda en pantallas grandes */
            }
        }
        /* General Card Styling */
        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-card);
            box-shadow: var(--shadow-card);
            border-radius: 8px; /* Consistent rounded corners */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .card-body {
            padding: 1.25rem; /* Consistent padding */
        }
        .card-title.h5, .card-title .h5 { /* Targeting h5 used as card titles */
            font-family: 'Roboto Slab', serif;
            font-size: 1.3rem; /* More prominent title */
            color: var(--text-card-title);
            margin-bottom: 1rem !important; /* Ensure spacing */
            border-bottom: 1px solid var(--border-card-title);
            padding-bottom: 0.5rem;
        }
        .card .list-group-item {
            background-color: var(--bg-list-item) !important;
            border-color: var(--border-list-item) !important;
            color: var(--text-list-item) !important;
            transition: background-color 0.2s ease, color 0.2s ease, border-left-color 0.2s ease;
            font-size: 0.95rem;
        }
        .card .list-group-item:hover, .card .list-group-item.active {
            background-color: var(--bg-list-item-hover) !important;
            color: var(--text-list-item-hover) !important;
            border-left: 3px solid var(--border-list-item-hover);
        }

        /* Button enhancements */
        .btn {
            font-weight: 500;
            letter-spacing: 0.5px;
            padding: 0.5rem 1rem; /* Default padding for most buttons */
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn-sm {
            padding: 0.35rem 0.8rem;
            font-size: 0.875rem;
        }
        .btn-theme.active {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: var(--piece-color-white); /* Ensure contrast */
        }
        .btn-outline-light { /* Ensure this adapts to theme */
            color: var(--btn-outline-text);
            border-color: var(--btn-outline-text);
        }

        /* Game Status & Player Info */
        #gameStatus {
            font-size: 1.3rem; /* Original: fs-5 (1.25rem) */
            padding: 10px 15px;
            background-color: var(--bg-list-item); /* Use a theme variable */
            border-radius: 6px;
            min-height: 50px; 
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.4;
            transition: background-color 0.3s ease;
        }
        #playerInfo .card {
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            background-color: var(--bg-list-item) !important; /* Use a theme variable */
        }
        #playerInfo .card .fw-bold { font-size: 1rem; }
        .player-active {
            border: 2px solid var(--warning-color) !important;
            box-shadow: 0 0 15px rgba(var(--warning-color-rgb), 0.5) !important;
        }

        /* Move History */
        .move-history {
            background-color: var(--bg-list-item); /* Use a theme variable */
            border-radius: 6px;
            padding: 10px 15px;
            max-height: 220px; /* Or adjust as needed */
            font-size: 0.9rem;
            border: 1px solid var(--border-list-item); /* Use a theme variable */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .move-entry {
            padding: 4px 5px;
            border-bottom: 1px solid rgba(var(--light-color-rgb),0.08);
            display: flex; /* For better alignment of number and moves */
            gap: 8px;
        }
        .move-entry:last-child { border-bottom: none; }
        .move-number {
            color: var(--secondary-color);
            font-weight: bold;
            min-width: 25px; /* Ensure consistent spacing for numbers */
        }

        /* Visual Effects */
        .square-capture-effect {
            animation: captureFlash 0.4s ease-out;
        }
        @keyframes captureFlash {
            0% { background-color: rgba(231, 76, 60, 0.0); }
            50% { background-color: rgba(231, 76, 60, 0.6); } /* More opaque red */
            100% { background-color: rgba(231, 76, 60, 0.0); } /* Original bg should show after */
        }
        .highlight-last-move-from, .highlight-last-move-to {
            background-color: rgba(var(--warning-color-rgb), 0.3) !important;
            box-shadow: inset 0 0 8px rgba(var(--warning-color-rgb), 0.5);
        }

        /* Game Stats */
        .game-stats .h4.h6 { /* Target the h4 styled as h6 */
            font-family: 'Roboto Slab', serif;
            color: var(--text-card-title); /* Align with card titles */
            border-bottom: 1px solid rgba(var(--secondary-color-rgb), 0.3);
            padding-bottom: 0.3rem;
            margin-bottom: 0.75rem !important;
            font-size: 1.1rem; /* Make it a bit larger than default h6 */
        }
        .stat-item {
            font-size: 0.95rem; /* Slightly larger */
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        .stat-label { color: var(--text-muted-main); }
        .stat-value {
            font-weight: 600; /* Bolder value */
        }

        #checkmateMessageOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.7); /* Start a bit larger */
            background-color: rgba(var(--dark-color-rgb, 44, 62, 80), 0.85); /* Use RGB for opacity */
            color: white;
            padding: 25px 45px;
            border-radius: 10px;
            font-size: clamp(1.5em, 4vw, 2.2em);
            font-weight: bold;
            z-index: 10; /* Above board pieces */
            opacity: 0;
            pointer-events: none; /* Don't intercept clicks */
            animation: fadeInScaleUp 0.8s ease-out forwards;
            display: none; /* Initially hidden, JS will control */
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        @keyframes fadeInScaleUp {
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        /* Chat Area */
        .chat-messages {
            background-color: var(--bg-list-item); /* Use a theme variable */
            border-radius: 6px;
            padding: 10px 15px;
            font-size: 0.9rem;
            min-height: 120px; /* Give it some default height */
            max-height: 200px; /* Prevent it from growing too large */
            overflow-y: auto;
            border: 1px solid var(--border-list-item); /* Use a theme variable */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .chat-messages strong { color: var(--text-card-title); } /* Align with card titles */
        #chatInput {
            background-color: var(--bg-input) !important;
            border-color: var(--border-input) !important;
            color: var(--text-input) !important;
            font-size: 0.95rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #chatInput::placeholder { color: var(--placeholder-input); }
        #chatInput:focus {
            box-shadow: 0 0 0 0.25rem rgba(var(--primary-color-rgb), 0.3);
            border-color: var(--text-card-title) !important; /* Align with card titles */
        }

        /* Modal Enhancements */
        .modal-content {
            background-color: var(--bg-modal);
            border: 1px solid var(--border-modal);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            color: var(--text-modal-body);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        .modal-header {
            border-bottom-color: var(--border-modal); /* Use variable */
        }
        .modal-header .modal-title {
            font-family: 'Roboto Slab', serif;
            color: var(--text-modal-title);
            font-size: 1.5rem;
        }
        .modal-footer {
            border-top-color: var(--border-modal); /* Use variable */
        }
        .modal-body {
            font-size: 1rem; /* Ensure modal body text is readable */
            color: var(--text-modal-body);
        }
        .modal-body h4 {
            font-family: 'Roboto Slab', serif;
            color: var(--secondary-color);
            margin-top: 1rem;
            margin-bottom: 0.75rem;
            font-size: 1.25rem;
        }
        .modal-body p, .modal-body li {
            line-height: 1.6;
            color: var(--text-modal-body);
        }
        .piece-promo-btn {
            font-size: 2.5rem !important; /* Make promotion pieces large */
            padding: 0.5rem 1rem !important;
            margin: 0 5px;
            background-color: rgba(var(--light-color-rgb),0.1);
            border: 1px solid rgba(var(--light-color-rgb),0.2);
            color: var(--piece-color-white); /* Ensure symbols are visible */
        }
        .piece-promo-btn:hover {
            background-color: rgba(var(--light-color-rgb),0.2);
            color: var(--warning-color);
        }

        .loading-spinner {
            width: 3rem;
            height: 3rem;
            border-width: .3em;
        }
        #geminiResponseModal .modal-body {
            min-height: 100px; /* For loading state */
        }

        .bot-message {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1050; /* Above most elements */
            min-width: 250px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(20px); }
        }

        /* Responsive adjustments */
        @media (max-width: 992px) { /* ... existing ... */ }
        @media (max-width: 768px) { /* ... existing ... */
             #audioControls { justify-content: center; } /* Center items if they wrap */
        }
        @media (max-width: 576px) { /* ... existing ... */
             #gameContainer { padding-top: 120px; } /* More space for wrapped audio controls */
            .card-title.h5, .card-title .h5 { font-size: 1.15rem; }
            #gameStatus { font-size: 1.1rem; }
            .btn { padding: 0.4rem 0.8rem; font-size: 0.9rem; }
        }

        /* --- Day Mode Styles --- */
        body.day-mode {
            --bg-main: #f4f7f6;
            --text-main: #333333;
            --text-muted-main: #555555;
            --bg-card: #ffffff;
            --border-card: #dddddd;
            --shadow-card: 0 5px 15px rgba(0,0,0,0.1);
            --text-card-title: #2980b9; /* Standard blue */
            --border-card-title: rgba(41, 128, 185, 0.3);
            --bg-list-item: #f9f9f9;
            --border-list-item: #eeeeee;
            --text-list-item: #333333;
            --bg-list-item-hover: #e0eaf0;
            --text-list-item-hover: #1c6ca7;
            --border-list-item-hover: #2980b9;
            --bg-input: #ffffff;
            --border-input: #cccccc;
            --text-input: #333333;
            --placeholder-input: #888888;
            --bg-modal: #fdfdfd;
            --border-modal: #dddddd;
            --text-modal-title: #2980b9;
            --text-modal-body: #333333;
            --board-classic-light: #f7f0e3; /* Light beige for classic board */
            --board-classic-dark: #c8b89c;  /* Muted tan for classic board */
            --btn-outline-text: #333333; /* Dark text for outline buttons in day mode */
        }

        body.day-mode #splashScreen h1 { color: var(--dark-color); text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        body.day-mode #splashScreen p { color: #444; }
        body.day-mode #splashScreen .btn-start-game { background-color: var(--primary-color); color: white; }
        body.day-mode #audioControls { background-color: rgba(var(--light-color-rgb), 0.95); color: var(--dark-color); box-shadow: 0 3px 10px rgba(0,0,0,0.2); }
        body.day-mode #audioControls button, body.day-mode #audioControls label { color: var(--dark-color); }
        body.day-mode #audioControls .btn-outline-warning, body.day-mode #audioControls .btn-outline-success, body.day-mode #audioControls .btn-outline-info {
             color: var(--dark-color); border-color: var(--dark-color);
        }
    </style>
</head>
<body>
    <div id="splashScreen">
        <h1>♛ Chess Arena Deluxe ♛</h1>
        <p>El juego de ajedrez más avanzado en tu navegador</p>
        <button id="enterGameBtn" class="btn btn-light btn-lg btn-start-game">
            <i class="fas fa-chess-knight"></i> Comenzar Partida
        </button>
    </div>

    <div id="audioControls">
        <div>
            <button id="musicToggleBtn" class="btn btn-sm btn-outline-warning"><i class="fas fa-music"></i> Música: <span id="musicStatus">OFF</span></button>
            <label for="volumeCtrl" class="ms-2">Vol:</label>
            <input type="range" id="volumeCtrl" class="form-range volume-slider" min="0" max="1" value="0.3" step="0.05">
        </div>
        
        <div class="title-area">
            <a href="{{ url_for('home') }}" class="logo-button-link" title="Ir a la página principal">
                <img src="{{ url_for('static', filename='img/logoaupachus.jpg') }}" alt="Logo Aupachus" class="header-logo">
            </a>
            <div class="game-title-bar">Chess Arena Deluxe</div>
        </div>

        <div>
            <button id="sfxToggleBtn" class="btn btn-sm btn-outline-success"><i class="fas fa-volume-up"></i> SFX: <span id="sfxStatus">ON</span></button>
            <label for="sfxVolumeCtrl" class="ms-2">Vol:</label>
            <input type="range" id="sfxVolumeCtrl" class="form-range volume-slider" min="0" max="1" value="0.5" step="0.05">
        </div>
        <div>
            <button class="btn btn-sm btn-outline-info" onclick="showHelpModal()"><i class="fas fa-question-circle"></i> Ayuda</button>
        </div>
        <div>
            <button id="themeToggleBtn" class="btn btn-sm btn-outline-light"><i class="fas fa-sun"></i> Modo Día</button>
        </div>
    </div>
    
    <!-- Audio Elements for Sound Effects -->
    <audio id="backgroundMusic" loop preload="auto"
        {% if music_tracks and music_tracks|length > 0 %}
            src="{{ url_for('static', filename=(audio_folder_name + '/' + music_tracks[0].filename)) }}"
        {% endif %}
    ></audio>
    <audio id="moveSound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_bb630cc098.mp3" preload="auto"></audio>
    <audio id="captureSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_163d801a15.mp3" preload="auto"></audio>
    <audio id="checkSound" src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_895dd32997.mp3" preload="auto"></audio>
    <audio id="gameWinSound" src="https://cdn.pixabay.com/download/audio/2022/01/20/audio_765804c097.mp3" preload="auto"></audio>
    <audio id="gameLoseSound" src="https://cdn.pixabay.com/download/audio/2022/02/11/audio_c087fe6959.mp3" preload="auto"></audio> <!-- Different lose sound -->
    <audio id="gameDrawSound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_127350392e.mp3" preload="auto"></audio>
    <audio id="errorSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_7018d0a84e.mp3" preload="auto"></audio> <!-- Short error beep -->


    <div id="gameContainer" class="text-white">
        <div class="container py-4">
            <header class="text-center mb-4">
                <h2 id="userStatus" class="lead fs-3">Modo: Individual vs IA</h2>
            </header>
            <div class="row g-lg-4 g-md-3 g-2">
                <div class="col-lg-3 col-md-4 order-md-1 order-2">
                    <!-- Left Panel Content (Modos de Juego, Personalización, Historial) -->
                     <div class="card bg-dark bg-opacity-75 mb-3">
                        <div class="card-body">
                            <h3 class="card-title h5 mb-3"><i class="fas fa-gamepad me-2"></i>Modos de Juego</h3>
                            <div class="d-grid gap-2 mb-3">
                                <button id="singlePlayerBtn" class="btn btn-success active"> 
                                    <i class="fas fa-robot me-2"></i>Jugar vs IA
                                </button>
                                <button id="multiPlayerBtn" class="btn btn-primary" disabled> 
                                    <i class="fas fa-users me-2"></i>Multijugador (Próximamente)
                                </button>
                            </div>
                            <div id="singlePlayerSection" class="mt-3">
                                <h4 class="h6 mb-2"><i class="fas fa-robot me-2"></i>Selecciona IA:</h4>
                                <div class="list-group">
                                    <button class="list-group-item list-group-item-action bg-dark text-white d-flex align-items-center" onclick="startBotGame('rookie')">
                                        <i class="fas fa-smile me-2"></i> Novato (Fácil)
                                    </button>
                                    <button class="list-group-item list-group-item-action bg-dark text-white d-flex align-items-center" onclick="startBotGame('master')">
                                        <i class="fas fa-brain me-2"></i> Intermedio
                                    </button>
                                    <button class="list-group-item list-group-item-action bg-dark text-white d-flex align-items-center" onclick="startBotGame('grandmaster')">
                                        <i class="fas fa-crown me-2"></i> Experto (Placeholder)
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card bg-dark bg-opacity-75 mb-3">
                        <div class="card-body">
                            <h3 class="card-title h5 mb-3"><i class="fas fa-palette me-2"></i>Personalización</h3>
                            <div class="d-flex flex-wrap gap-2 theme-buttons mb-3">
                                <button class="btn btn-sm btn-theme btn-outline-light active" data-theme="classic" onclick="changeTheme('classic')">
                                    <i class="fas fa-chess-board me-1"></i> Clásico
                                </button>
                                <button class="btn btn-sm btn-theme btn-outline-light" data-theme="futuristic" onclick="changeTheme('futuristic')">
                                    <i class="fas fa-atom me-1"></i> Futurista
                                </button>
                                <button class="btn btn-sm btn-theme btn-outline-light" data-theme="lego" onclick="changeTheme('lego')">
                                    <i class="fas fa-cubes me-1"></i> Lego
                                </button>
                            </div>
                            
                            <div class="game-stats">
                                <h4 class="h6 mb-2"><i class="fas fa-chart-line me-2"></i>Estadísticas</h4>
                                <div class="stat-item">
                                    <span class="stat-label">Piezas blancas:</span>
                                    <span class="stat-value" id="whitePiecesCount">16</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Piezas negras:</span>
                                    <span class="stat-value" id="blackPiecesCount">16</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Movimientos:</span>
                                    <span class="stat-value" id="movesCount">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card bg-dark bg-opacity-75">
                        <div class="card-body">
                            <h3 class="card-title h5 mb-3"><i class="fas fa-history me-2"></i>Historial de Movimientos</h3>
                            <div class="move-history" id="moveHistoryContainer">
                                <div class="text-muted small">El historial aparecerá aquí</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="col-lg-6 col-md-8 order-md-2 order-1">
                    <div class="card bg-dark bg-opacity-75 mb-3">
                        <div class="card-body text-center">
                            <div id="gameStatus" class="mb-3 fw-bold fs-5">Selecciona un oponente para comenzar</div>
                            <div id="playerInfo" class="d-flex justify-content-center gap-3 mb-3 d-none">
                                <div id="player1" class="card bg-secondary text-white" style="width: 150px;">
                                    <div class="card-body p-2 text-center">
                                        <div class="fw-bold">⚪ Tú</div>
                                        <small id="player1Timer" class="d-block">--:--</small>
                                    </div>
                                </div>
                                <div id="player2" class="card bg-secondary text-white" style="width: 150px;">
                                    <div class="card-body p-2 text-center">
                                        <div class="fw-bold" id="player2Name">⚫ IA</div>
                                        <small id="player2Timer" class="d-block">--:--</small>
                                    </div>
                                </div>
                            </div>
                            <div id="chessBoardWrapper" style="position: relative;"> <!-- Wrapper for overlay -->
                                <div id="chessBoard" class="chess-board mb-3"></div>
                                <div id="checkmateMessageOverlay">¡JAQUE MATE!</div>
                            </div>
                            <div id="opponentMoveAnalysisContainer" class="mb-2" style="min-height: 38px;"></div>
                            <div id="gameControls" class="d-flex justify-content-center flex-wrap gap-2 d-none"> 
                                <button class="btn btn-warning" onclick="confirmResetGame()"><i class="fas fa-sync-alt me-1"></i> Reiniciar</button>
                                <button class="btn btn-info" onclick="undoMove()" title="Deshacer último movimiento (1)" disabled><i class="fas fa-undo me-1"></i> Deshacer</button>
                                <button class="btn btn-secondary" onclick="offerDrawModal()" title="Proponer tablas" disabled><i class="fas fa-handshake me-1"></i> Tablas</button>
                                <button class="btn btn-danger" onclick="resignModal()" title="Rendirse"><i class="fas fa-flag me-1"></i> Rendirse</button>
                                <button id="strategicTipBtn" class="btn btn-primary gemini-btn" onclick="requestStrategicTip()" disabled><i class="fas fa-lightbulb me-1"></i> Consejo IA</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="col-lg-3 col-md-12 order-md-3 order-3">
                    <!-- Right Panel Content (Chat, Reglas) -->
                     <div class="card bg-dark bg-opacity-75 mb-3">
                        <div class="card-body">
                            <h3 class="card-title h5 mb-3"><i class="fas fa-comments me-2"></i>Chat del Juego</h3>
                            <div class="chat-messages mb-3" id="gameChat">
                                <div class="text-muted small">Bienvenido al chat del juego. Escribe un mensaje para comenzar.</div>
                            </div>
                            <div class="input-group">
                                <input type="text" id="chatInput" class="form-control bg-dark text-white border-secondary" placeholder="Escribe aquí..." autocomplete="off">
                                <button class="btn btn-primary" onclick="sendChatMessage()"><i class="fas fa-paper-plane"></i></button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card bg-dark bg-opacity-75">
                        <div class="card-body">
                            <h3 class="card-title h5 mb-3"><i class="fas fa-chess me-2"></i>Reglas del Ajedrez</h3>
                            <div class="small">
                                <p><strong>Objetivo:</strong> Dar jaque mate al rey contrario.</p>
                                <p><strong>Movimientos:</strong> Cada pieza se mueve de forma única.</p>
                                <p><strong>Jaque:</strong> El rey está bajo amenaza.</p>
                                <p><strong>Jaque mate:</strong> El rey no puede escapar.</p>
                                <button class="btn btn-sm btn-outline-info mt-2 w-100" onclick="showHelpModal()">
                                    <i class="fas fa-question-circle me-1"></i> Ver todas las reglas
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="botMessages"></div>
    
    <!-- Modals (Confirmation, Gemini, Help, Promotion) -->
    <div class="modal fade" id="confirmationModal" tabindex="-1" aria-labelledby="confirmationModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="confirmationModalLabel">Confirmar Acción</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p id="confirmationModalMessage">¿Estás seguro?</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="button" class="btn btn-primary" id="confirmActionBtn">Confirmar</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal fade" id="geminiResponseModal" tabindex="-1" aria-labelledby="geminiResponseModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="geminiResponseModalLabel">✨ Asistente IA de Ajedrez</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="geminiResponseContent">
                    <!-- Content will be injected here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="helpModalLabel">Reglas del Ajedrez y Ayuda</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <h4>Movimiento de las Piezas</h4>
                    <p><strong>Rey (♔♚):</strong> Se mueve una casilla en cualquier dirección. No puede moverse a una casilla amenazada.</p>
                    <p><strong>Reina (♕♛):</strong> Se mueve cualquier número de casillas en línea recta: horizontal, vertical o diagonal.</p>
                    <p><strong>Torre (♖♜):</strong> Se mueve cualquier número de casillas horizontal o verticalmente.</p>
                    <p><strong>Alfil (♗♝):</strong> Se mueve cualquier número de casillas diagonalmente. Cada alfil permanece en casillas de su color original.</p>
                    <p><strong>Caballo (♘♞):</strong> Se mueve en forma de "L": dos casillas en una dirección (horizontal o vertical) y luego una casilla perpendicular. Es la única pieza que puede saltar sobre otras.</p>
                    <p><strong>Peón (♙♟):</strong>
                        <ul>
                            <li>Se mueve una casilla hacia adelante. En su primer movimiento, puede optar por moverse una o dos casillas hacia adelante.</li>
                            <li>Captura diagonalmente una casilla hacia adelante.</li>
                            <li><strong>Promoción:</strong> Si un peón alcanza el otro extremo del tablero, se convierte en cualquier otra pieza (generalmente una reina).</li>
                            <li><strong>Captura al Paso (En Passant):</strong> Si un peón avanza dos casillas desde su posición inicial y aterriza junto a un peón oponente, este último puede capturarlo como si el primer peón solo hubiera avanzado una casilla. Esta captura debe realizarse inmediatamente en el siguiente turno.</li>
                        </ul>
                    </p>
                    <h4>Movimientos Especiales</h4>
                    <p><strong>Enroque (Castling):</strong> Un movimiento que involucra al rey y una de las torres.
                        <ul>
                            <li>El rey se mueve dos casillas hacia la torre, y la torre salta al otro lado del rey.</li>
                            <li>Condiciones: Ni el rey ni la torre involucrada deben haberse movido previamente. No debe haber piezas entre el rey y la torre. El rey no puede estar en jaque, ni pasar por una casilla amenazada, ni terminar en una casilla amenazada.</li>
                        </ul>
                    </p>
                    <h4>Fin del Juego</h4>
                    <p><strong>Jaque Mate (Checkmate):</strong> El rey está en jaque y no hay ningún movimiento legal para escapar del jaque. El jugador que da jaque mate gana.</p>
                    <p><strong>Tablas (Draw):</strong>
                        <ul>
                            <li><strong>Rey Ahogado (Stalemate):</strong> El jugador cuyo turno es no tiene movimientos legales y su rey no está en jaque.</li>
                            <li><strong>Acuerdo Mutuo:</strong> Ambos jugadores acuerdan empatar.</li>
                            <li><strong>Triple Repetición:</strong> La misma posición se repite tres veces con el mismo jugador alTocar.</li>
                            <li><strong>Regla de los 50 Movimientos:</strong> Si durante 50 movimientos consecutivos no ha habido capturas ni movimientos de peón.</li>
                            <li><strong>Material Insuficiente:</strong> No hay suficientes piezas en el tablero para forzar un jaque mate (ej. rey contra rey, rey y alfil contra rey).</li>
                        </ul>
                    </p>
                    <h4>Cómo Jugar</h4>
                    <p>Haz clic en una de tus piezas para seleccionarla. Las casillas a las que se puede mover se resaltarán. Haz clic en una casilla resaltada para mover tu pieza. ¡Intenta dar jaque mate al rey de la IA!</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="promotionModal" tabindex="-1" aria-labelledby="promotionModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="promotionModalLabel">¡Promoción de Peón!</h5>
                </div>
                <div class="modal-body text-center">
                    <p>Elige una pieza para promocionar tu peón:</p>
                    <button class="btn btn-lg piece-promo-btn piece-white" data-piece="q">♕</button> <!-- Added piece-white for styling -->
                    <button class="btn btn-lg piece-promo-btn piece-white" data-piece="r">♖</button>
                    <button class="btn btn-lg piece-promo-btn piece-white" data-piece="b">♗</button>
                    <button class="btn btn-lg piece-promo-btn piece-white" data-piece="n">♘</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- DOM Elements ---
        const chessBoardElement = document.getElementById('chessBoard');
        const gameStatusElement = document.getElementById('gameStatus');
        const player1InfoElement = document.getElementById('player1');
        const player2InfoElement = document.getElementById('player2');
        const player2NameElement = document.getElementById('player2Name');
        const whitePiecesCountElement = document.getElementById('whitePiecesCount');
        const blackPiecesCountElement = document.getElementById('blackPiecesCount');
        const movesCountElement = document.getElementById('movesCount');
        const moveHistoryContainer = document.getElementById('moveHistoryContainer');
        const splashScreen = document.getElementById('splashScreen');
        const enterGameBtn = document.getElementById('enterGameBtn');
        const gameContainer = document.getElementById('gameContainer');
        const audioControlsElement = document.getElementById('audioControls'); // Renamed for clarity
        const musicToggleBtn = document.getElementById('musicToggleBtn');
        const musicStatusElement = document.getElementById('musicStatus');
        const volumeCtrl = document.getElementById('volumeCtrl');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const chatInputElement = document.getElementById('chatInput');
        const gameChatElement = document.getElementById('gameChat');
        const strategicTipBtn = document.getElementById('strategicTipBtn');
        const undoBtn = document.querySelector('button[onclick="undoMove()"]');
        const offerDrawBtn = document.querySelector('button[onclick="offerDrawModal()"]');
        const gameControlsElement = document.getElementById('gameControls');
        const playerInfoElement = document.getElementById('playerInfo');
        const checkmateOverlayElement = document.getElementById('checkmateMessageOverlay');
        const themeToggleBtn = document.getElementById('themeToggleBtn');

        // SFX DOM Elements
        const sfxToggleBtn = document.getElementById('sfxToggleBtn');
        const sfxStatusElement = document.getElementById('sfxStatus');
        const sfxVolumeCtrl = document.getElementById('sfxVolumeCtrl');
        const moveSound = document.getElementById('moveSound');
        const captureSound = document.getElementById('captureSound');
        const checkSound = document.getElementById('checkSound');
        const gameWinSound = document.getElementById('gameWinSound');
        const gameLoseSound = document.getElementById('gameLoseSound');
        const gameDrawSound = document.getElementById('gameDrawSound');
        const errorSound = document.getElementById('errorSound');


        // --- Game State ---
        let board = []; 
        let currentPlayer = 'white'; 
        let selectedSquare = null; 
        let gameMode = 'none'; 
        let botDifficulty = 'rookie';
        let gameOver = true;
        let moveHistory = []; 
        let fiftyMoveRuleCounter = 0;
        let positionHistory = {}; 

        let castlingRights = [true, true, true, true]; 
        let enPassantTarget = null; 

        const PIECES = { /* ... (no change) ... */
            'P': { type: 'pawn', color: 'white', symbol: '♙' },
            'R': { type: 'rook', color: 'white', symbol: '♖' },
            'N': { type: 'knight', color: 'white', symbol: '♘' },
            'B': { type: 'bishop', color: 'white', symbol: '♗' },
            'Q': { type: 'queen', color: 'white', symbol: '♕' },
            'K': { type: 'king', color: 'white', symbol: '♔' },
            'p': { type: 'pawn', color: 'black', symbol: '♟' },
            'r': { type: 'rook', color: 'black', symbol: '♜' },
            'n': { type: 'knight', color: 'black', symbol: '♞' },
            'b': { type: 'bishop', color: 'black', symbol: '♝' },
            'q': { type: 'queen', color: 'black', symbol: '♛' },
            'k': { type: 'king', color: 'black', symbol: '♚' }
        };
        const INITIAL_BOARD_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        
        // --- Modals ---
        let confirmationModal, geminiResponseModal, helpModal, promotionModalInstance;

        // --- SFX State ---
        let sfxOn = true;
        let sfxVolume = 0.5;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
            geminiResponseModal = new bootstrap.Modal(document.getElementById('geminiResponseModal'));
            helpModal = new bootstrap.Modal(document.getElementById('helpModal'));
            promotionModalInstance = new bootstrap.Modal(document.getElementById('promotionModal'));
            
            createBoardHTML();
            setupEventListeners();
            changeTheme('classic'); 
            updateGameStatus("Selecciona un oponente para comenzar.");
            document.documentElement.style.setProperty('--dark-color-rgb', '44, 62, 80'); // For checkmate overlay
        });

        function setupEventListeners() {
            enterGameBtn.addEventListener('click', () => {
                splashScreen.classList.add('hidden');
                gameContainer.style.display = 'block';
                audioControlsElement.style.display = 'flex';
                if(sfxOn) playSound(moveSound); // Small sound for game start
            });

            musicToggleBtn.addEventListener('click', toggleMusic);
            volumeCtrl.addEventListener('input', (e) => {
                backgroundMusic.volume = parseFloat(e.target.value);
            });
            backgroundMusic.volume = parseFloat(volumeCtrl.value);

            sfxToggleBtn.addEventListener('click', toggleSfx);
            sfxVolumeCtrl.addEventListener('input', (e) => {
                sfxVolume = parseFloat(e.target.value);
                // Test sound with errorSound if user changes volume
                if(sfxOn && errorSound.readyState >= 2) playSound(errorSound); 
            });
            sfxVolume = parseFloat(sfxVolumeCtrl.value); // Initialize

            chatInputElement.addEventListener('keypress', (e) => { /* ... (no change) ... */
                if (e.key === 'Enter' && chatInputElement.value.trim() !== '') {
                    sendChatMessage();
                }
            });

            document.querySelectorAll('.piece-promo-btn').forEach(btn => { /* ... (no change) ... */
                btn.addEventListener('click', (e) => {
                    const pieceType = e.target.getAttribute('data-piece');
                    promotionModalInstance.hide();
                    completePromotion(pieceType);
                });
            });

            // Theme Toggle Logic
            const bodyElement = document.body;
            const sunIcon = '<i class="fas fa-sun"></i>';
            const moonIcon = '<i class="fas fa-moon"></i>';

            function applyTheme(theme) {
                if (theme === 'day') {
                    bodyElement.classList.add('day-mode');
                    themeToggleBtn.innerHTML = moonIcon + ' Modo Noche';
                    localStorage.setItem('chessArenaTheme', 'day');
                } else { // night or any other value
                    bodyElement.classList.remove('day-mode');
                    themeToggleBtn.innerHTML = sunIcon + ' Modo Día';
                    localStorage.setItem('chessArenaTheme', 'night');
                }
            }

            themeToggleBtn.addEventListener('click', () => {
                const currentTheme = bodyElement.classList.contains('day-mode') ? 'day' : 'night';
                applyTheme(currentTheme === 'day' ? 'night' : 'day');
            });

            const savedTheme = localStorage.getItem('chessArenaTheme') || 'night'; // Default to night
            applyTheme(savedTheme);
        }
        
        function createBoardHTML() { /* ... (no change) ... */
            chessBoardElement.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.r = r;
                    square.dataset.c = c;
                    square.addEventListener('click', () => handleSquareClick(r, c));
                    chessBoardElement.appendChild(square);
                }
            }
        }

        function fenToBoard(fen) { /* ... (no change) ... */
            const [piecePlacement, activeColor, castling, enPassant, halfMove, fullMove] = fen.split(" ");
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            
            let r = 0, c = 0;
            for (const char of piecePlacement) {
                if (char === '/') {
                    r++;
                    c = 0;
                } else if (/\d/.test(char)) {
                    c += parseInt(char);
                } else {
                    board[r][c] = PIECES[char];
                    c++;
                }
            }
            currentPlayer = activeColor === 'w' ? 'white' : 'black';
            
            castlingRights = [
                castling.includes('K'),
                castling.includes('Q'),
                castling.includes('k'),
                castling.includes('q')
            ];

            if (enPassant === '-') {
                enPassantTarget = null;
            } else {
                const col = enPassant.charCodeAt(0) - 'a'.charCodeAt(0);
                const row = 8 - parseInt(enPassant[1]);
                enPassantTarget = { r: row, c: col };
            }
            fiftyMoveRuleCounter = parseInt(halfMove);
            // Corrected movesCount update
            const baseMoves = (parseInt(fullMove) - 1) * 2;
            const currentTurnMoves = (activeColor === 'b' && piecePlacement !== INITIAL_BOARD_FEN.split(" ")[0]) ? 1 : 0; // Only add if not initial pos and black to move
            movesCountElement.textContent = baseMoves + currentTurnMoves;

            positionHistory = {}; 
            addPositionToHistory(); 
        }

        function boardToFen() { /* ... (no change) ... */
            let fen = '';
            // Piece placement
            for (let r = 0; r < 8; r++) {
                let emptyCount = 0;
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        if (emptyCount > 0) fen += emptyCount;
                        emptyCount = 0;
                        fen += Object.keys(PIECES).find(key => PIECES[key] === piece);
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (r < 7) fen += '/';
            }

            // Active color
            fen += ` ${currentPlayer === 'white' ? 'w' : 'b'}`;

            // Castling availability
            let castlingStr = "";
            if (castlingRights[0]) castlingStr += 'K';
            if (castlingRights[1]) castlingStr += 'Q';
            if (castlingRights[2]) castlingStr += 'k';
            if (castlingRights[3]) castlingStr += 'q';
            fen += ` ${castlingStr || '-'}`;

            // En passant target square
            if (enPassantTarget) {
                fen += ` ${String.fromCharCode('a'.charCodeAt(0) + enPassantTarget.c)}${8 - enPassantTarget.r}`;
            } else {
                fen += ' -';
            }

            // Halfmove clock (for 50-move rule)
            fen += ` ${fiftyMoveRuleCounter}`;

            // Fullmove number
            const fullMoves = Math.floor(moveHistory.length / 2) + 1;
            fen += ` ${fullMoves}`;

            return fen;
        }


        function initGame() {
            gameOver = false;
            fenToBoard(INITIAL_BOARD_FEN);
            selectedSquare = null;
            moveHistory = [];
            // fiftyMoveRuleCounter = 0; // fenToBoard handles this
            // positionHistory = {}; // fenToBoard handles this
            // addPositionToHistory(); // fenToBoard handles this

            renderBoard();
            updatePlayerInfo();
            updateGameStatus(currentPlayer === 'white' ? "Turno de las Blancas" : "Turno de las Negras");
            updatePieceCounts();
            // updateMovesCountDisplay(); // fenToBoard handles this now via moveHistory length and fullMove num.
            clearMoveHistoryUI();
            addChatMessage('Sistema', 'Nueva partida iniciada.');
            gameControlsElement.classList.remove('d-none');
            playerInfoElement.classList.remove('d-none');
            undoBtn.disabled = true;
            strategicTipBtn.disabled = false;
            offerDrawBtn.disabled = false;
            checkmateOverlayElement.style.display = 'none'; // Hide overlay

            if (currentPlayer === 'black' && gameMode === 'bot') {
                setTimeout(makeBotMove, 500);
            }
        }
        
        window.startBotGame = function(difficulty) { /* ... (no change) ... */
            gameMode = 'bot';
            botDifficulty = difficulty;
            player2NameElement.textContent = `⚫ IA (${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)})`;
            initGame();
        }

        function renderBoard() {
            const currentTheme = chessBoardElement.dataset.theme || 'classic';
            // Apply board-level theme classes first
            chessBoardElement.classList.remove('futuristic-board-active', 'lego-board-active', 'piece-style-classic', 'piece-style-lego');
            if (currentTheme === 'futuristic') {
                chessBoardElement.classList.add('futuristic-board-active');
            } else if (currentTheme === 'lego') {
                chessBoardElement.classList.add('lego-board-active', 'piece-style-lego');
            } else { // classic
                chessBoardElement.classList.add('piece-style-classic');
            }

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const squareElement = chessBoardElement.children[r * 8 + c];
                    const piece = board[r][c];
                    squareElement.innerHTML = ''; 
                    // Preserve effect classes if they were set by makeMove, otherwise reset
                    const preservedClasses = ['square-capture-effect']; // Add more if needed
                    let classesToKeep = '';
                    preservedClasses.forEach(cls => {
                        if(squareElement.classList.contains(cls)) classesToKeep += cls + ' ';
                    });

                    squareElement.className = 'square ' + classesToKeep; // Reset classes but keep specified ones
                    squareElement.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    
                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.classList.add('piece');
                        // Add specific color class for the piece
                        pieceSpan.classList.add(piece.color === 'white' ? 'piece-white' : 'piece-black');
                        pieceSpan.textContent = piece.symbol;
                        squareElement.appendChild(pieceSpan);
                        // squareElement.classList.add('has-piece'); // Not strictly needed anymore with .piece child

                        // Theme-specific classes on SQUARE for futuristic piece styling
                        if (currentTheme === 'futuristic') {
                            squareElement.classList.add(piece.color === 'white' ? 'futuristic-white-piece' : 'futuristic-black-piece');
                        }
                    }
                    // Remove old dynamic highlights that are re-applied by selectPiece or highlightLastMove
                    squareElement.classList.remove('selected', 'possible-move', 'capture-move', 'highlight-last-move-from', 'highlight-last-move-to');
                }
            }
            highlightLastMove();
        }

        function highlightLastMove() { /* ... (no change) ... */
            if (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                const fromSquare = chessBoardElement.children[lastMove.from.r * 8 + lastMove.from.c];
                const toSquare = chessBoardElement.children[lastMove.to.r * 8 + lastMove.to.c];
                fromSquare.classList.add('highlight-last-move-from');
                toSquare.classList.add('highlight-last-move-to');
            }
        }


        function handleSquareClick(r, c) {
            if (gameOver) return;
            if (currentPlayer === 'black' && gameMode === 'bot') return; 

            const piece = board[r][c];

            if (selectedSquare) {
                const fromR = selectedSquare.r;
                const fromC = selectedSquare.c;
                const legalMoves = getLegalMoves(fromR, fromC);
                const isMovePossible = legalMoves.some(move => move.r === r && move.c === c);

                if (isMovePossible) {
                    makeMove(fromR, fromC, r, c);
                } else if (piece && piece.color === currentPlayer) {
                    selectPiece(r,c);
                } else {
                    playSound(errorSound);
                    clearHighlights();
                    selectedSquare = null;
                }
            } else if (piece && piece.color === currentPlayer) {
                selectPiece(r, c);
            } else {
                playSound(errorSound); // Clicked empty or opponent piece with nothing selected
            }
        }
        
        function selectPiece(r, c) { /* ... (no change) ... */
            clearHighlights();
            selectedSquare = { r, c };
            chessBoardElement.children[r * 8 + c].classList.add('selected');
            const legalMoves = getLegalMoves(r, c);
            legalMoves.forEach(move => {
                const targetSquare = chessBoardElement.children[move.r * 8 + move.c];
                targetSquare.classList.add('possible-move');
                if (board[move.r][move.c] || (board[r][c].type === 'pawn' && move.c !== c && !board[move.r][move.c])) { // Capture or en passant
                    targetSquare.classList.add('capture-move');
                }
            });
        }

        function clearHighlights() { /* ... (no change) ... */
            document.querySelectorAll('.square.selected, .square.possible-move, .square.capture-move').forEach(sq => {
                sq.classList.remove('selected', 'possible-move', 'capture-move');
            });
        }
        
        let promotionResolver = null; 

        function makeMove(fromR, fromC, toR, toC, promotionChoice = null) {
            const pieceToMove = board[fromR][fromC];
            if (!pieceToMove) return;

            const capturedPiece = board[toR][toC]; 
            const targetSquareElement = chessBoardElement.children[toR * 8 + toC]; // Get element for effects

            // Handle pawn promotion
            if (pieceToMove.type === 'pawn' && ( (pieceToMove.color === 'white' && toR === 0) || (pieceToMove.color === 'black' && toR === 7) )) {
                if (!promotionChoice) {
                    promotionModalInstance.show();
                    const moveDetails = { fromR, fromC, toR, toC, pieceToMove, capturedPiece, targetSquareElement };
                    return new Promise((resolve) => {
                        promotionResolver = (chosenPieceType) => {
                            completePawnPromotionAndMove(moveDetails, chosenPieceType);
                            resolve(); 
                        };
                    });
                } else {
                    const newType = promotionChoice.toLowerCase();
                    const newPieceKey = pieceToMove.color === 'white' ? newType.toUpperCase() : newType;
                    board[toR][toC] = { ...PIECES[newPieceKey] }; 
                }
            } else {
                 board[toR][toC] = pieceToMove;
            }
           
            board[fromR][fromC] = null;

             const moveData = { /* ... (no change) ... */
                from: { r: fromR, c: fromC },
                to: { r: toR, c: toC },
                piece: pieceToMove,
                captured: capturedPiece,
                promotedTo: promotionChoice,
                fenBefore: boardToFen(), // FEN before this move
                castlingRightsBefore: [...castlingRights],
                enPassantTargetBefore: enPassantTarget ? {...enPassantTarget} : null,
                fiftyMoveRuleCounterBefore: fiftyMoveRuleCounter
            };

            // Handle En Passant capture
            if (pieceToMove.type === 'pawn' && enPassantTarget && toR === enPassantTarget.r && toC === enPassantTarget.c) { /* ... (no change) ... */
                if (pieceToMove.color === 'white') board[toR + 1][toC] = null; // Captured black pawn
                else board[toR - 1][toC] = null; // Captured white pawn
                moveData.captured = PIECES[pieceToMove.color === 'white' ? 'p' : 'P']; // Record en-passant capture
            }

            enPassantTarget = null;
            if (pieceToMove.type === 'pawn' && Math.abs(toR - fromR) === 2) { /* ... (no change) ... */
                enPassantTarget = { r: (fromR + toR) / 2, c: fromC };
            }

            if (pieceToMove.type === 'king' && Math.abs(toC - fromC) === 2) { /* ... (no change) ... */
                if (toC > fromC) { // Kingside
                    board[fromR][fromC + 1] = board[fromR][7]; // Move rook
                    board[fromR][7] = null;
                } else { // Queenside
                    board[fromR][fromC - 1] = board[fromR][0]; // Move rook
                    board[fromR][0] = null;
                }
            }
            
            // Update castling rights (no change to logic)
            if (pieceToMove.type === 'king') { /* ... */ }
            if (pieceToMove.type === 'rook') { /* ... */ }
            if (capturedPiece && capturedPiece.type === 'rook') { /* ... */ }


            if (pieceToMove.type === 'pawn' || capturedPiece) { /* ... (no change) ... */
                fiftyMoveRuleCounter = 0;
            } else {
                fiftyMoveRuleCounter++;
            }
            
            moveHistory.push(moveData);
            addPositionToHistory(); 

            // SFX and Visual Effects
            if (capturedPiece) {
                playSound(captureSound);
                targetSquareElement.classList.add('square-capture-effect');
                setTimeout(() => targetSquareElement.classList.remove('square-capture-effect'), 400); // Duration matches animation
            } else {
                playSound(moveSound);
            }

            selectedSquare = null;
            renderBoard();
            updatePieceCounts();
            updateMovesCountDisplay();
            addMoveToHistoryUI(fromR, fromC, toR, toC, pieceToMove, capturedPiece, promotionChoice);
            
            switchPlayer();
            checkGameState(); 

            if (!gameOver && currentPlayer === 'black' && gameMode === 'bot') {
                 setTimeout(makeBotMove, 500 + Math.random() * 500); 
            }
             undoBtn.disabled = moveHistory.length === 0;
            return Promise.resolve(); 
        }

        function completePromotion(chosenPieceType) { /* ... (no change) ... */
            if (promotionResolver) {
                promotionResolver(chosenPieceType);
                promotionResolver = null; // Reset resolver
            }
        }
        
        function completePawnPromotionAndMove(moveDetails, promotionChoice) {
            const { fromR, fromC, toR, toC, pieceToMove, capturedPiece, targetSquareElement } = moveDetails;

            const newType = promotionChoice.toLowerCase();
            const newPieceKey = pieceToMove.color === 'white' ? newType.toUpperCase() : newType;
            board[toR][toC] = { ...PIECES[newPieceKey] }; 
            board[fromR][fromC] = null;

             const moveData = { /* ... (no change to content) ... */
                from: { r: fromR, c: fromC },
                to: { r: toR, c: toC },
                piece: pieceToMove, // Original pawn
                captured: capturedPiece,
                promotedTo: promotionChoice,
                fenBefore: boardToFen(), 
                castlingRightsBefore: [...castlingRights],
                enPassantTargetBefore: enPassantTarget ? {...enPassantTarget} : null,
                fiftyMoveRuleCounterBefore: fiftyMoveRuleCounter
            };
            
            // En Passant and Castling updates (no change to logic)
            if (pieceToMove.type === 'pawn' && enPassantTarget && toR === enPassantTarget.r && toC === enPassantTarget.c) { /* ... */ }
            enPassantTarget = null;
            if (pieceToMove.type === 'king') { /* ... */ } 
            if (pieceToMove.type === 'rook') { /* ... */ } 
            if (capturedPiece && capturedPiece.type === 'rook') { /* ... */ }

            fiftyMoveRuleCounter = 0; 
            
            moveHistory.push(moveData);
            addPositionToHistory();

            // SFX and Visual Effects for promotion (usually a non-capture move sound)
            playSound(moveSound); // Or a specific promotion sound if you have one
            if (capturedPiece) { // If promotion was also a capture
                playSound(captureSound); // Play capture sound too, or a combined one
                targetSquareElement.classList.add('square-capture-effect');
                setTimeout(() => targetSquareElement.classList.remove('square-capture-effect'), 400);
            }


            selectedSquare = null;
            renderBoard();
            updatePieceCounts();
            updateMovesCountDisplay();
            addMoveToHistoryUI(fromR, fromC, toR, toC, pieceToMove, capturedPiece, promotionChoice);
            
            switchPlayer();
            checkGameState(); 

            if (!gameOver && currentPlayer === 'black' && gameMode === 'bot') {
                 setTimeout(makeBotMove, 500 + Math.random() * 500);
            }
            undoBtn.disabled = moveHistory.length === 0;
        }


        function switchPlayer() { /* ... (no change) ... */
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
            updatePlayerInfo();
        }

        function updatePlayerInfo() { /* ... (no change) ... */
            player1InfoElement.classList.toggle('player-active', currentPlayer === 'white' && !gameOver);
            player2InfoElement.classList.toggle('player-active', currentPlayer === 'black' && !gameOver);
        }
        
        function updateGameStatus(message, isCheck = false) { /* ... (no change) ... */
            // function updateGameStatus(message, isCheck = false) {
            gameStatusElement.textContent = message;
            
            // Reset specific status classes
            gameStatusElement.classList.remove('status-check', 'status-select-opponent');

            if (message === "Selecciona un oponente para comenzar") {
                gameStatusElement.classList.add('status-select-opponent');
            } else if (isCheck) { // Only apply check if not the "select opponent" message
                gameStatusElement.classList.add('status-check');
            }
        }
        
        function updatePieceCounts() { /* ... (no change) ... */
            let whiteCount = 0;
            let blackCount = 0;
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    if(board[r][c]) {
                        if(board[r][c].color === 'white') whiteCount++;
                        else blackCount++;
                    }
                }
            }
            whitePiecesCountElement.textContent = whiteCount;
            blackPiecesCountElement.textContent = blackCount;
        }
        
        function updateMovesCountDisplay() { /* ... (no change) ... */
            movesCountElement.textContent = moveHistory.length;
        }

        function colToChar(col) { return String.fromCharCode('a'.charCodeAt(0) + col); }
        function rowToChar(row) { return (8 - row).toString(); }

        function addMoveToHistoryUI(fromR, fromC, toR, toC, piece, captured, promotion) { /* ... (no change to logic, but better formatting might be desired) ... */
            if (moveHistoryContainer.children.length === 1 && moveHistoryContainer.firstElementChild.classList.contains('text-muted')) {
                moveHistoryContainer.innerHTML = ''; // Clear "El historial aparecerá aquí"
            }
            
            const moveNum = Math.floor((moveHistory.length -1) / 2) + 1;
            const moveEntryDiv = document.createElement('div');
            moveEntryDiv.classList.add('move-entry');

            let notation = '';
            if (piece.type === 'king' && Math.abs(toC - fromC) === 2) { // Castling
                notation = (toC > fromC) ? 'O-O' : 'O-O-O';
            } else {
                notation += piece.type !== 'pawn' ? piece.symbol : ''; // Use symbol for pieces
                if (piece.type === 'pawn' && captured) {
                     notation += colToChar(fromC); 
                }
                if (captured) notation += 'x';
                notation += colToChar(toC) + rowToChar(toR);
                if (promotion) notation += '=' + PIECES[piece.color === 'white' ? promotion.toUpperCase() : promotion].symbol;
            }
            
            const tempCurrentPlayer = currentPlayer; // Store current player before simulating for check/checkmate status
            currentPlayer = piece.color === 'white' ? 'black' : 'white'; // Temporarily switch to opponent for check status
            if (isCheckmate(currentPlayer, board)) { // Check if opponent is checkmated
                notation += '#';
            } else if (isKingInCheck(currentPlayer, board)) { // Check if opponent is in check
                notation += '+';
            }
            currentPlayer = tempCurrentPlayer; // Restore current player

            if (piece.color === 'white') {
                const numSpan = document.createElement('span');
                numSpan.classList.add('move-number');
                numSpan.textContent = `${moveNum}.`;
                moveEntryDiv.appendChild(numSpan);

                const whiteMoveSpan = document.createElement('span');
                whiteMoveSpan.innerHTML = notation; // Use innerHTML for symbols
                moveEntryDiv.appendChild(whiteMoveSpan);
                moveHistoryContainer.appendChild(moveEntryDiv); // Append new entry for white

            } else { // Black's move
                let lastEntry = moveHistoryContainer.lastElementChild;
                if (lastEntry && lastEntry.children.length < 3) { 
                     const blackMoveSpan = document.createElement('span');
                     blackMoveSpan.innerHTML = notation; // Use innerHTML for symbols
                     lastEntry.appendChild(blackMoveSpan);
                } else { 
                    // This case should ideally not happen if white always moves first in a numbered entry
                    const numSpan = document.createElement('span');
                    numSpan.classList.add('move-number');
                    numSpan.textContent = `${moveNum}.`;
                    moveEntryDiv.appendChild(numSpan);
                    const placeholderSpan = document.createElement('span');
                    placeholderSpan.textContent = "..."; 
                    moveEntryDiv.appendChild(placeholderSpan);
                    const blackMoveSpan = document.createElement('span');
                    blackMoveSpan.innerHTML = notation;
                    moveEntryDiv.appendChild(blackMoveSpan);
                    moveHistoryContainer.appendChild(moveEntryDiv);
                }
            }
            moveHistoryContainer.scrollTop = moveHistoryContainer.scrollHeight;
        }

        function clearMoveHistoryUI() { /* ... (no change) ... */
            moveHistoryContainer.innerHTML = '<div class="text-muted small">El historial aparecerá aquí</div>';
        }

        // --- Chess Logic (Movement, Check, Checkmate) - NO CHANGES TO CORE LOGIC ---
        function getLegalMoves(r, c) { /* ... (no change) ... */
            const piece = board[r][c];
            if (!piece || piece.color !== currentPlayer) return [];

            let pseudoLegalMoves = [];
            switch (piece.type) {
                case 'pawn': pseudoLegalMoves = getPawnMoves(r, c, piece.color); break;
                case 'rook': pseudoLegalMoves = getSlidingMoves(r, c, piece.color, [[0, 1], [0, -1], [1, 0], [-1, 0]]); break;
                case 'knight': pseudoLegalMoves = getKnightMoves(r, c, piece.color); break;
                case 'bishop': pseudoLegalMoves = getSlidingMoves(r, c, piece.color, [[1, 1], [1, -1], [-1, 1], [-1, -1]]); break;
                case 'queen': pseudoLegalMoves = getSlidingMoves(r, c, piece.color, [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]); break;
                case 'king': pseudoLegalMoves = getKingMoves(r, c, piece.color); break;
            }
            
            const legalMoves = pseudoLegalMoves.filter(move => {
                const tempBoard = board.map(arr => arr.slice()); 
                const originalPieceAtTarget = tempBoard[move.r][move.c];
                const originalPieceAtSource = tempBoard[r][c];

                tempBoard[move.r][move.c] = tempBoard[r][c];
                tempBoard[r][c] = null;

                if (piece.type === 'pawn' && enPassantTarget && move.r === enPassantTarget.r && move.c === enPassantTarget.c) {
                    if (piece.color === 'white') tempBoard[move.r + 1][move.c] = null;
                    else tempBoard[move.r - 1][move.c] = null;
                }
                const kingInCheck = isKingInCheck(currentPlayer, tempBoard);
                return !kingInCheck;
            });
            return legalMoves;
        }
        function getPawnMoves(r, c, color) { /* ... (no change) ... */
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;

            // Forward one square
            if (isValid(r + direction, c) && !board[r + direction][c]) {
                moves.push({ r: r + direction, c: c });
                // Forward two squares (from starting position)
                if (r === startRow && isValid(r + 2 * direction, c) && !board[r + 2 * direction][c]) {
                    moves.push({ r: r + 2 * direction, c: c });
                }
            }
            // Captures
            [-1, 1].forEach(dc => {
                if (isValid(r + direction, c + dc) && board[r + direction][c + dc] && board[r + direction][c + dc].color !== color) {
                    moves.push({ r: r + direction, c: c + dc });
                }
            });
            // En Passant
            if (enPassantTarget && enPassantTarget.r === r + direction && Math.abs(enPassantTarget.c - c) === 1) {
                 if (board[r][enPassantTarget.c] && board[r][enPassantTarget.c].type === 'pawn' && board[r][enPassantTarget.c].color !== color) {
                    moves.push({ r: enPassantTarget.r, c: enPassantTarget.c });
                 }
            }
            return moves;
        }
        function getSlidingMoves(r, c, color, directions) { /* ... (no change) ... */
            const moves = [];
            directions.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (!isValid(nr, nc)) break;
                    if (board[nr][nc]) {
                        if (board[nr][nc].color !== color) moves.push({ r: nr, c: nc });
                        break; 
                    }
                    moves.push({ r: nr, c: nc });
                }
            });
            return moves;
        }
        function getKnightMoves(r, c, color) { /* ... (no change) ... */
            const moves = [];
            const knightOffsets = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
            knightOffsets.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;
                if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].color !== color)) {
                    moves.push({ r: nr, c: nc });
                }
            });
            return moves;
        }
        function getKingMoves(r, c, color) { /* ... (no change) ... */
            const moves = [];
            const kingOffsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
            kingOffsets.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;
                if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].color !== color)) {
                    moves.push({ r: nr, c: nc });
                }
            });

            // Castling
            const canCastleKingSide = color === 'white' ? castlingRights[0] : castlingRights[2];
            const canCastleQueenSide = color === 'white' ? castlingRights[1] : castlingRights[3];

            if (canCastleKingSide && !board[r][c+1] && !board[r][c+2] && 
                !isSquareAttacked(r, c, color === 'white' ? 'black' : 'white', board) &&
                !isSquareAttacked(r, c+1, color === 'white' ? 'black' : 'white', board) &&
                !isSquareAttacked(r, c+2, color === 'white' ? 'black' : 'white', board) ) {
                moves.push({ r: r, c: c + 2 });
            }
            if (canCastleQueenSide && !board[r][c-1] && !board[r][c-2] && !board[r][c-3] &&
                !isSquareAttacked(r, c, color === 'white' ? 'black' : 'white', board) &&
                !isSquareAttacked(r, c-1, color === 'white' ? 'black' : 'white', board) &&
                !isSquareAttacked(r, c-2, color === 'white' ? 'black' : 'white', board) ) {
                 moves.push({ r: r, c: c - 2 });
            }
            return moves;
        }
        function isValid(r, c) { /* ... (no change) ... */ return r >= 0 && r < 8 && c >= 0 && c < 8; }
        function getKingPosition(color, currentBoard) { /* ... (no change) ... */
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] && currentBoard[r][c].type === 'king' && currentBoard[r][c].color === color) {
                        return { r, c };
                    }
                }
            }
            return null; 
        }
        function isSquareAttacked(r, c, attackerColor, currentBoard) { /* ... (no change) ... */
            // Check for pawn attacks
            const pawnDir = attackerColor === 'white' ? 1 : -1; // Pawns attack "backwards" from their move direction to reach (r,c)
            if (isValid(r + pawnDir, c - 1) && currentBoard[r + pawnDir][c - 1] && currentBoard[r + pawnDir][c - 1].type === 'pawn' && currentBoard[r + pawnDir][c - 1].color === attackerColor) return true;
            if (isValid(r + pawnDir, c + 1) && currentBoard[r + pawnDir][c + 1] && currentBoard[r + pawnDir][c + 1].type === 'pawn' && currentBoard[r + pawnDir][c + 1].color === attackerColor) return true;

            // Check for knight attacks
            const knightOffsets = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
            for (const [dr, dc] of knightOffsets) {
                if (isValid(r + dr, c + dc) && currentBoard[r + dr][c + dc] && currentBoard[r + dr][c + dc].type === 'knight' && currentBoard[r + dr][c + dc].color === attackerColor) return true;
            }

            // Check for sliding pieces (rook, bishop, queen)
            const rookDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            const bishopDirections = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const directions of [rookDirections, bishopDirections]) {
                const pieceType = directions === rookDirections ? ['rook', 'queen'] : ['bishop', 'queen'];
                for (const [dr, dc] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const nr = r + dr * i;
                        const nc = c + dc * i;
                        if (!isValid(nr, nc)) break;
                        if (currentBoard[nr][nc]) {
                            if (currentBoard[nr][nc].color === attackerColor && pieceType.includes(currentBoard[nr][nc].type)) return true;
                            break; 
                        }
                    }
                }
            }
            
            // Check for king attacks (for proximity, not actual check)
            const kingOffsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
            for (const [dr, dc] of kingOffsets) {
                if (isValid(r + dr, c + dc) && currentBoard[r + dr][c + dc] && currentBoard[r + dr][c + dc].type === 'king' && currentBoard[r + dr][c + dc].color === attackerColor) return true;
            }
            return false;
        }
        function isKingInCheck(kingColor, currentBoard) { /* ... (no change) ... */
            const kingPos = getKingPosition(kingColor, currentBoard);
            if (!kingPos) return false; 
            return isSquareAttacked(kingPos.r, kingPos.c, kingColor === 'white' ? 'black' : 'white', currentBoard);
        }
        function hasLegalMoves(color, currentBoard) { /* ... (no change) ... */
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.color === color) {
                        const originalPlayer = currentPlayer;
                        currentPlayer = color;
                        const moves = getLegalMoves(r, c); 
                        currentPlayer = originalPlayer; 
                        if (moves.length > 0) return true;
                    }
                }
            }
            return false;
        }
        function isCheckmate(kingColor, currentBoard) { /* ... (no change) ... */ return isKingInCheck(kingColor, currentBoard) && !hasLegalMoves(kingColor, currentBoard); }
        function isStalemate(playerColor, currentBoard) { /* ... (no change) ... */ return !isKingInCheck(playerColor, currentBoard) && !hasLegalMoves(playerColor, currentBoard); }
        function isInsufficientMaterial() { /* ... (no change) ... */
            const piecesOnBoard = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c]) piecesOnBoard.push(board[r][c]);
                }
            }

            if (piecesOnBoard.length <= 2) return true; // K vs K
            if (piecesOnBoard.length === 3) {
                const types = piecesOnBoard.map(p => p.type);
                if (types.includes('knight') || types.includes('bishop')) return true; // K+N vs K or K+B vs K
            }
            if (piecesOnBoard.length === 4) {
                const bishops = piecesOnBoard.filter(p => p.type === 'bishop');
                if (bishops.length === 2) {
                    const b1Pos = findPiece(bishops[0]);
                    const b2Pos = findPiece(bishops[1]);
                    if (b1Pos && b2Pos && (b1Pos.r + b1Pos.c) % 2 === (b2Pos.r + b2Pos.c) % 2) { 
                        const kings = piecesOnBoard.filter(p => p.type === 'king');
                        // Check if bishops belong to different players
                        if (bishops[0].color !== bishops[1].color && kings.length === 2) return true;
                    }
                }
            }
            return false;
        }
        function findPiece(pieceToFind) { /* ... (no change) ... */ 
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === pieceToFind) return {r, c};
                }
            }
            return null;
        }
        function addPositionToHistory() { /* ... (no change) ... */
            const fenKey = boardToFen().split(' ').slice(0, 4).join(' '); 
            positionHistory[fenKey] = (positionHistory[fenKey] || 0) + 1;
        }

        function checkGameState() {
            const winnerColor = currentPlayer === 'white' ? 'black' : 'white'; // The player who just moved might have caused checkmate
            const loserColor = currentPlayer;

            if (isCheckmate(loserColor, board)) {
                gameOver = true;
                const winnerDisplay = winnerColor.charAt(0).toUpperCase() + winnerColor.slice(1) + (winnerColor === 'white' ? 's' : 's');
                updateGameStatus(`¡Jaque Mate! Ganan las ${winnerDisplay}.`);
                addChatMessage('Sistema', `¡Jaque Mate! Ganan las ${winnerDisplay}.`);
                playSound(winnerColor === 'white' ? gameWinSound : gameLoseSound); // Assuming player is white
                disableGameControlsPostGame();
                checkmateOverlayElement.textContent = `¡JAQUE MATE!\nGanan las ${winnerDisplay}`;
                animateCheckmateOverlay();
            } else if (isStalemate(loserColor, board)) {
                gameOver = true;
                updateGameStatus("¡Tablas por Rey Ahogado!");
                addChatMessage('Sistema', "¡Tablas por Rey Ahogado!");
                playSound(gameDrawSound);
                disableGameControlsPostGame();
                 checkmateOverlayElement.textContent = "¡TABLAS!\nRey Ahogado";
                animateCheckmateOverlay();
            } else if (fiftyMoveRuleCounter >= 100) { 
                 gameOver = true;
                updateGameStatus("¡Tablas por la regla de los 50 movimientos!");
                addChatMessage('Sistema', "¡Tablas por la regla de los 50 movimientos!");
                playSound(gameDrawSound);
                disableGameControlsPostGame();
                checkmateOverlayElement.textContent = "¡TABLAS!\n50 Movimientos";
                animateCheckmateOverlay();
            } else if (Object.values(positionHistory).some(count => count >= 3)) {
                gameOver = true;
                updateGameStatus("¡Tablas por triple repetición!");
                addChatMessage('Sistema', "¡Tablas por triple repetición!");
                playSound(gameDrawSound);
                disableGameControlsPostGame();
                checkmateOverlayElement.textContent = "¡TABLAS!\nTriple Repetición";
                animateCheckmateOverlay();
            } else if (isInsufficientMaterial()) {
                gameOver = true;
                updateGameStatus("¡Tablas por material insuficiente!");
                addChatMessage('Sistema', "¡Tablas por material insuficiente!");
                playSound(gameDrawSound);
                disableGameControlsPostGame();
                checkmateOverlayElement.textContent = "¡TABLAS!\nMaterial Insuficiente";
                animateCheckmateOverlay();
            } else {
                checkmateOverlayElement.style.display = 'none'; // Hide if not game over
                const inCheck = isKingInCheck(currentPlayer, board); // Check for current player's king
                updateGameStatus(currentPlayer === 'white' ? "Turno de las Blancas" + (inCheck ? " (¡Jaque!)" : "") : "Turno de las Negras" + (inCheck ? " (¡Jaque!)" : ""), inCheck);
                if(inCheck) playSound(checkSound);
            }
            updatePlayerInfo(); 
        }

        function animateCheckmateOverlay() {
            checkmateOverlayElement.style.display = 'block';
            checkmateOverlayElement.style.animation = 'none'; // Reset animation
            checkmateOverlayElement.offsetHeight; // Trigger reflow to restart animation
            checkmateOverlayElement.style.animation = ''; // Re-apply animation
        }
        
        function disableGameControlsPostGame() { /* ... (no change) ... */
            strategicTipBtn.disabled = true;
            offerDrawBtn.disabled = true;
        }

        // --- AI Opponent ---
        function makeBotMove() { /* ... (no change) ... */
            if (gameOver) return;
            
            let allPossibleMoves = []; 
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].color === currentPlayer) {
                        const legalMoves = getLegalMoves(r, c);
                        legalMoves.forEach(move => {
                            allPossibleMoves.push({ from: { r, c }, to: move, piece: board[r][c] });
                        });
                    }
                }
            }

            if (allPossibleMoves.length === 0) {
                checkGameState(); 
                return;
            }

            let bestMove;
            if (botDifficulty === 'rookie' || botDifficulty === 'grandmaster') { 
                bestMove = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
            } else if (botDifficulty === 'master') {
                let captureMoves = allPossibleMoves.filter(m => board[m.to.r][m.to.c] !== null);
                if (captureMoves.length > 0) {
                    const pieceValues = { pawn: 1, knight: 3, bishop: 3, rook: 5, queen: 9, king: 100};
                    captureMoves.sort((a,b) => {
                        const valA = board[a.to.r][a.to.c] ? pieceValues[board[a.to.r][a.to.c].type] : 0;
                        const valB = board[b.to.r][b.to.c] ? pieceValues[board[b.to.r][b.to.c].type] : 0;
                        return valB - valA; 
                    });
                    bestMove = captureMoves[0];

                } else {
                    bestMove = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
                }
            }
            
            let promotionChoice = null;
            if (bestMove.piece.type === 'pawn' && (bestMove.to.r === 0 || bestMove.to.r === 7)) {
                promotionChoice = 'q'; 
            }

            makeMove(bestMove.from.r, bestMove.from.c, bestMove.to.r, bestMove.to.c, promotionChoice);
            document.getElementById('opponentMoveAnalysisContainer').textContent = `IA (${botDifficulty}) movió ${bestMove.piece.symbol} de ${colToChar(bestMove.from.c)}${rowToChar(bestMove.from.r)} a ${colToChar(bestMove.to.c)}${rowToChar(bestMove.to.r)}.`;
            setTimeout(() => { document.getElementById('opponentMoveAnalysisContainer').textContent = ''; }, 3000);
        }

        // --- Game Controls ---
        function confirmResetGame() { /* ... (no change) ... */
            document.getElementById('confirmationModalMessage').textContent = "¿Estás seguro de que quieres reiniciar la partida?";
            document.getElementById('confirmActionBtn').onclick = resetGame;
            confirmationModal.show();
        }

        window.resetGame = function() { 
            if (confirmationModal && confirmationModal._isShown) confirmationModal.hide(); // Hide modal if open
            if (gameMode === 'none') { 
                updateGameStatus("Selecciona un oponente para comenzar.");
                addChatMessage('Sistema', 'Partida reiniciada. Selecciona un oponente.');
            } else {
                startBotGame(botDifficulty); 
            }
            checkmateOverlayElement.style.display = 'none'; // Ensure overlay is hidden
        }
        
        window.undoMove = function() { /* ... (no change) ... */
            if (moveHistory.length === 0 || gameOver) {
                playSound(errorSound);
                return;
            } 
            
            const movesToUndo = (gameMode === 'bot' && moveHistory.length >= 2 && currentPlayer === 'white') ? 2 : 1;

            for (let i = 0; i < movesToUndo; i++) {
                if (moveHistory.length === 0) break;
                const lastMove = moveHistory.pop();
                fenToBoard(lastMove.fenBefore); 
                const fenKey = lastMove.fenBefore.split(' ').slice(0, 4).join(' ');
                if (positionHistory[fenKey] > 1) positionHistory[fenKey]--;
                else delete positionHistory[fenKey];
            }

            gameOver = false; 
            checkmateOverlayElement.style.display = 'none'; // Hide overlay on undo
            renderBoard();
            updatePlayerInfo();
            updatePieceCounts();
            updateMovesCountDisplay();
            
            const tempHistory = [...moveHistory];
            clearMoveHistoryUI();
            moveHistory = []; 
            tempHistory.forEach(move => {
                 addMoveToHistoryUI(move.from.r, move.from.c, move.to.r, move.to.c, move.piece, move.captured, move.promotedTo);
            });

            updateGameStatus(currentPlayer === 'white' ? "Turno de las Blancas" : "Turno de las Negras");
             if (isKingInCheck(currentPlayer, board)) {
                updateGameStatus(gameStatusElement.textContent + " (¡Jaque!)", true);
            }
            
            undoBtn.disabled = moveHistory.length === 0;
            addChatMessage('Sistema', 'Movimiento deshecho.');
            playSound(moveSound); // Sound for undo
        }

        window.offerDrawModal = function() { /* ... (no change) ... */
            if (gameOver) return;
            document.getElementById('confirmationModalMessage').textContent = (gameMode === 'bot') ? 
                "La IA acepta las tablas. ¿Confirmar?" : 
                "¿Ofrecer tablas al oponente?";
            document.getElementById('confirmActionBtn').onclick = confirmDraw;
            confirmationModal.show();
        }

        function confirmDraw() {
            gameOver = true;
            updateGameStatus("¡Tablas por acuerdo mutuo!");
            addChatMessage('Sistema', "¡Tablas por acuerdo mutuo!");
            playSound(gameDrawSound);
            confirmationModal.hide();
            disableGameControlsPostGame();
            updatePlayerInfo(); 
            checkmateOverlayElement.textContent = "¡TABLAS!\nAcuerdo Mutuo";
            animateCheckmateOverlay();
        }

        window.resignModal = function() { /* ... (no change) ... */
            if (gameOver) return;
            document.getElementById('confirmationModalMessage').textContent = "¿Estás seguro de que quieres rendirte?";
            document.getElementById('confirmActionBtn').onclick = confirmResign;
            confirmationModal.show();
        }

        function confirmResign() {
            gameOver = true;
            const winner = currentPlayer === 'white' ? 'Negras' : 'Blancas'; // If white resigns, black wins
            updateGameStatus(`Te has rendido. Ganan las ${winner}.`);
            addChatMessage('Sistema', `El jugador ${currentPlayer} se rinde. Ganan las ${winner}.`);
            playSound(currentPlayer === 'white' ? gameLoseSound : gameWinSound); // Player's perspective
            confirmationModal.hide();
            disableGameControlsPostGame();
            updatePlayerInfo(); 
            checkmateOverlayElement.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} se rinde.\nGanan las ${winner}`;
            animateCheckmateOverlay();
        }


        // --- Theme Customization ---
        window.changeTheme = function(themeName) { /* ... (no change) ... */
            chessBoardElement.dataset.theme = themeName; 

            chessBoardElement.classList.remove('futuristic-board-active', 'lego-board-active', 'piece-style-classic', 'piece-style-lego');
            
            if (themeName === 'futuristic') {
                chessBoardElement.classList.add('futuristic-board-active');
            } else if (themeName === 'lego') {
                chessBoardElement.classList.add('lego-board-active', 'piece-style-lego');
            } else { 
                chessBoardElement.classList.add('piece-style-classic');
            }
            renderBoard(); 

            document.querySelectorAll('.theme-buttons .btn-theme').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.theme === themeName) {
                    btn.classList.add('active');
                }
            });
             addChatMessage('Sistema', `Tema cambiado a ${themeName}.`);
             playSound(moveSound); // Sound for theme change
        }

        // --- SFX and Audio Controls ---
        function toggleMusic() { /* ... (no change) ... */
            if (backgroundMusic.paused) {
                backgroundMusic.play().catch(e => console.error("Error playing music:", e));
                musicStatusElement.textContent = 'ON';
                musicToggleBtn.classList.remove('btn-outline-warning');
                musicToggleBtn.classList.add('btn-warning');
            } else {
                backgroundMusic.pause();
                musicStatusElement.textContent = 'OFF';
                musicToggleBtn.classList.remove('btn-warning');
                musicToggleBtn.classList.add('btn-outline-warning');
            }
        }

        function toggleSfx() {
            sfxOn = !sfxOn;
            sfxStatusElement.textContent = sfxOn ? 'ON' : 'OFF';
            sfxToggleBtn.classList.toggle('btn-outline-success', !sfxOn);
            sfxToggleBtn.classList.toggle('btn-success', sfxOn);
            if(sfxOn) playSound(moveSound); // Play a sound to confirm SFX are on
        }

        function playSound(soundElement) {
            if (sfxOn && soundElement && soundElement.readyState >= 2) { // readyState 2 (HAVE_CURRENT_DATA) or higher
                soundElement.currentTime = 0; 
                soundElement.volume = sfxVolume;
                soundElement.play().catch(e => console.warn("Error playing sound:", e.message)); 
            }
        }
        
        // --- Chat ---
        window.sendChatMessage = function() { /* ... (no change) ... */
            const message = chatInputElement.value.trim();
            if (message) {
                addChatMessage('Tú', message);
                chatInputElement.value = '';
                if (gameMode === 'bot') {
                    setTimeout(() => {
                        const botResponses = ["Interesante...", "Buen movimiento.", "Hmm.", "Ya veremos.", "Calculando..."];
                        addChatMessage('IA', botResponses[Math.floor(Math.random() * botResponses.length)]);
                    }, 1000 + Math.random() * 1000);
                }
            }
        }

        function addChatMessage(sender, message) { /* ... (no change) ... */
            if (gameChatElement.children.length === 1 && gameChatElement.firstElementChild.classList.contains('text-muted')) {
                gameChatElement.innerHTML = ''; 
            }
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('mb-1', 'small');
            const senderStrong = document.createElement('strong');
            senderStrong.textContent = sender + ": ";
            messageDiv.appendChild(senderStrong);
            messageDiv.appendChild(document.createTextNode(message));
            gameChatElement.appendChild(messageDiv);
            gameChatElement.scrollTop = gameChatElement.scrollHeight;
        }

        // --- Modals & AI Help ---
        window.showHelpModal = function() { /* ... (no change) ... */ helpModal.show(); }
        window.requestStrategicTip = function() { /* ... (no change) ... */
            if (gameOver) {
                showBotMessage("La partida ha terminado, no hay más consejos.", "info");
                return;
            }
            const geminiModalBody = document.getElementById('geminiResponseContent');
            geminiModalBody.innerHTML = `
                <div class="d-flex justify-content-center align-items-center">
                    <div class="spinner-border loading-spinner text-light" role="status">
                        <span class="visually-hidden">Analizando...</span>
                    </div>
                    <span class="ms-2">Analizando...</span>
                </div>`;
            geminiResponseModal.show();

            setTimeout(() => { 
                let tip = "Analiza bien tus opciones. ";
                if (isKingInCheck(currentPlayer, board)) {
                    tip += "¡Tu rey está en jaque! Debes moverlo o bloquear el jaque. ";
                }
                
                const allPlayerMoves = [];
                 for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] && board[r][c].color === currentPlayer) {
                            const legalMoves = getLegalMoves(r, c); 
                            legalMoves.forEach(move => {
                                allPlayerMoves.push({ from: { r, c }, to: move, piece: board[r][c] });
                            });
                        }
                    }
                }

                if(allPlayerMoves.length > 0) {
                    const randomConsideration = allPlayerMoves[Math.floor(Math.random() * allPlayerMoves.length)];
                    tip += `Considera mover tu ${PIECES[Object.keys(PIECES).find(key => PIECES[key] === randomConsideration.piece)].type} de ${colToChar(randomConsideration.from.c)}${rowToChar(randomConsideration.from.r)} a ${colToChar(randomConsideration.to.c)}${rowToChar(randomConsideration.to.r)}. `;
                    
                    if (board[randomConsideration.to.r][randomConsideration.to.c]) {
                        tip += "Esto te permitiría capturar una pieza. ";
                    }
                    const startRow = currentPlayer === 'white' ? [6,7] : [0,1];
                    if (startRow.includes(randomConsideration.from.r) && !startRow.includes(randomConsideration.to.r) && (randomConsideration.piece.type === 'knight' || randomConsideration.piece.type === 'bishop')) {
                        tip += "Desarrollar tus piezas menores es importante. ";
                    }

                } else {
                    tip += "Parece que no tienes movimientos legales. ";
                }
                tip += "Recuerda controlar el centro y mantener tu rey seguro."
                geminiModalBody.textContent = tip;
            }, 1500);
        }
        function showBotMessage(message, type = 'info') { /* ... (no change) ... */
            const botMessagesContainer = document.getElementById('botMessages');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show bot-message`;
            alertDiv.setAttribute('role', 'alert');
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            botMessagesContainer.appendChild(alertDiv);
            setTimeout(() => {
                if (bootstrap.Alert.getOrCreateInstance(alertDiv)) { // Check if alert still exists
                     bootstrap.Alert.getOrCreateInstance(alertDiv).close();
                }
            }, 3500);
        }

    </script>
</body>
</html>